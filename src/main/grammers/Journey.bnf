{
  parserClass="com.qalens.corr.lang.core.parser.JourneyParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jrn"
  psiImplClassSuffix="Impl"
  psiPackage="com.qalens.corr.lang.core.psi"
  psiImplPackage="com.qalens.corr.lang.core.psi.impl"

  elementTypeHolderClass="com.qalens.corr.lang.core.psi.JrnElementTypes"
  elementTypeClass="com.qalens.corr.lang.core.psi.JrnElementType"
  tokenTypeClass="com.qalens.corr.lang.core.psi.JrnTokenType"

  psiImplUtilClass="com.qalens.corr.lang.core.psi.impl.JourneyPsiImplUtil"
  tokens = [
          DOT = '.'
          SCRIPLET_START = '<%'
          SCRIPLET_END = '%>'
          LBRACE      = '{'
          RBRACE      = '}'
          LBRACK      =  '['
          RBRACK      =  ']'
          LPAREN      =  '('
          RPAREN      =  ')'
          COLON       =  ':'
          SEMICOLON   =  ';'
          COMMA       =  ','
          BACKTICK    =  '`'
          UNDERSCORE  =  '_'
          QUOTE      =  '"'
          ASSIGN     =  '='
          STRING      = 'String'
          BOOL      = 'Boolean'
          DOUBLE    = 'Double'
          POSITIVE_INTEGER = 'PositiveInteger'
          INTEGER = 'Integer'
          LIST      = 'List'
          OBJECT      = 'Object'
          CONCAT = 'concat'
          FROMJSON = 'from_json'
          MUL = 'mul'
          DIV = 'div'
          ADD = 'add'
          SUB = 'sub'
          FAKE = 'fake'
          ENCODE = 'encode'
          TIMESTAMP = 'timestamp'
          NOW = 'now'
          MOD = 'mod'
          UUID = 'uuid'
          ASYNC = 'async'
          WITH = 'with'
          RESPOND = 'respond'
          SYNC = 'sync'
          ON = 'on'
          LISTEN = 'listen'
          RANDOM = 'random'
          RANDOMELEMENT = 'random_element'
          ROUND = 'round'
          PRINT  = 'print'
          TEXT = 'text'
          FOR = 'for'
          PUSH = 'push'
          IF = 'if'
          TO = 'to'
          LOAD = 'load'
          FROM = 'from'
          SANDBOX = 'sandbox'
          ELSE = 'else'
          LET = 'let'
          MATCHING = 'matching'
          BODY = 'body'
          HEADERS = 'headers'
          REQUEST = 'request'
          AND = 'and'
          OBJECT_TEMPLATE = 'object'
          URL = 'url'
          GET = 'get'
          PUT = 'put'
          POST = 'post'
          PATCH = 'patch'
          DELETE = 'delete'
          FATARROW = '=>'
          OP_EQUAL = '=='
          OP_PLUS = '+'
          OP_MINUS = '-'
          OP_DIVIDE = '/'
          OP_MULTIPLY = '*'
          OP_MOD = '%'
          OP_INCREMENT = '++'
          OP_DECREMENT = '--'

      ]
}
journeyFile ::= RootFn
RootFn ::= JourneyName '(' ')' '{' Statement* '}'
JourneyName ::= identifier | NAME
Statement ::= PrintStatement | PushStatement| ForStatement | LoadStep | SyncStep | ListenerStep | IfElseStatement | LetStatement | RestStep
LetStatement ::= 'let' VariableReference '=' Assignable
LoadStep ::= 'let' VariableReference '=' 'load' Expression ('from' 'sandbox' Expression)?
SyncStep ::= 'sync' VariableReference ('to' 'sandbox' Expression)?
ListenerStep ::= 'listen' 'on' Expression 'with' '{' StubPart* '}'
StubPart ::=  'on' 'get' 'with' 'url' ExtractableText ( 'matching' 'request' (HeadersStartingRestData | BodyStartingRestData))? '{' Statement* 'respond' 'with' 'body' Expression '}'
IfElseStatement ::= 'if' Expression '{' Statement* '}' ('else' 'if' '{' Statement* '}')* ('else' '{' Statement* '}')?
RestStep ::= ('async')? ( 'get' | 'put' | 'post' | 'patch' | 'delete') FillableRequestTemplate ( 'matching' (HeadersStartingRestData | BodyStartingRestData))?
HeadersStartingRestData ::= 'headers' ExtractableHeaders ('and' 'body' ExtractableTemplate)?
BodyStartingRestData ::=   'body' ExtractableTemplate ('and' 'headers' ExtractableHeaders)?
ExtractableTemplate ::= ('object' ExtractableObjectTemplate)
ExtractableObjectTemplate ::= ExtractableForLoop | VariableReference | ExtractableObjectMap | ExtractableStaticArray
ExtractableObjectMap ::= '{' ExtractablePair ( ',' ExtractablePair)* '}'
ExtractableStaticArray ::= '[' ExtractableObjectTemplate (',' ExtractableObjectTemplate)* ']'
ExtractableForLoop ::= VariableReference '.' 'for' '(' VariableReference ')' '=>' ExtractableObjectTemplate
ExtractablePair ::= STRING_LITERAL ':' ExtractableObjectTemplate

ExtractableHeaders ::= '{' STRING_LITERAL ':' VariableReference (',' STRING_LITERAL ':' VariableReference)* '}'
FillableRequestTemplate ::= 'request' '{'
  'url' ':' (Expression | FillableTextTemplate)
  ( ',' 'body' ':' FillableObjectTemplate)?
  ( ',' 'headers' ':' FillableHeaders)? '}'
FillableHeaders ::= '{' HeaderPair (',' HeaderPair)* '}'
HeaderPair ::= STRING_LITERAL ':' (Expression | FillableTextTemplate)
Assignable ::= Expression | FillableObjectTemplate | FillableTextTemplate
FillableObjectTemplate ::= 'object' ObjectValueTemplate
ObjectValueTemplate ::= FillableForLoop | Expression | FillableMapTemplate | FillableArrayTemplate
FillableMapTemplate ::= '{'  (FillbaleObjectPair (',' FillbaleObjectPair)*)? '}'
FillbaleObjectPair ::= STRING_LITERAL ':' ObjectValueTemplate
FillableArrayTemplate ::= '[' (ObjectValueTemplate (',' ObjectValueTemplate)*)? ']'
FillableForLoop ::= VariableReference '.' 'for' (FillableForLoopWithArguments | FillableForLoopWithoutArguments)
FillableForLoopWithArguments ::= '(' VariableReference (',' VariableReference )? ')' '=>' ObjectValueTemplate
FillableForLoopWithoutArguments ::= ObjectValueTemplate
PrintStatement ::= 'print' FillableTextTemplate
ForStatement ::= VariableReference '.' 'for' ( UnArgedFor | ArgedFor)
PushStatement ::= VariableReference '.' 'push' ( Expression )
UnArgedFor ::= Statement | MultipleStatement
ArgedFor ::= '(' ( (VariableReference ',' VariableReference) | VariableReference?) ')' '=>' (Statement | MultipleStatement)
MultipleStatement ::= '{' (Statement)* '}'
FillableTextTemplate ::= 'text' TextTemplate
ExtractableText ::= 'text' '`' (SingleVariableText | MultiVariableText) '`'
SingleVariableText ::= '<%' VariableExpression '%>'
MultiVariableText ::= (TEXT_LITERAL)? ('<%' VariableExpression '%>' TEXT_LITERAL)* ('<%' VariableExpression '%>')?
TextTemplate ::= '`' TextBlock* '`'
TextBlock ::= Scriplet | TEXT_LITERAL
Scriplet ::= '<%' (TextScript) '%>'
TextScript ::= ForLoopInText | Expression
ForLoopInText ::= VariableReference '.' 'for' (UnArgedForInText | ArgedForInText )
UnArgedForInText ::= ForBlockForText
ForBlockForText ::= TextScript | ( '%>' (TextBlock)* '<%' )
ArgedForInText ::= '(' ( (VariableReference ',' VariableReference) | VariableReference?) ')' '=>' ForBlockForText
Expression ::=  OperatorExpression | NonOperatorExpression
NonOperatorExpression  ::= BracketedExpression | ConstantExpression | FunctionExpression | VariableExpression
BracketedExpression ::= '(' Expression ')'
OperatorExpression ::= BinaryOperatorExpression | UnaryOperatorExpression
BinaryOperatorExpression ::= ((UnaryOperatorExpression | NonOperatorExpression) BinaryOperator)+ (UnaryOperatorExpression | NonOperatorExpression)
UnaryOperatorExpression ::= NonOperatorExpression UnaryOperator
BinaryOperator ::= '+' | '-' | '/' | '*' | '%' | '=='
UnaryOperator ::= '++' | '--'
ConstantExpression ::= STRING_LITERAL | DoubleValue | PositiveIntegerValue | InetegerValue | NullValue | BooleanValue
FunctionExpression ::= MultiValuedFunction | BinaryFunction | UnaryFunction | NoArgFunction
MultiValuedFunction ::= ('concat' | 'mul' | 'add') '(' (Expression (',' Expression)*)? ')'
BinaryFunction ::= ('round' | 'random' | 'sub' | 'div' | 'mod') '(' (Expression ',' Expression)  ')'
UnaryFunction ::= ('fake' | 'from_json' | 'random_element' | 'encode' | 'now'  ) '(' Expression  ')'
NoArgFunction ::= ('uuid' |  'timestamp' | 'now' ) '('  ')'
VariableExpression ::= VariableReference (':' Type)?
VariableReference ::= identifier ('.' identifier)*
Type ::= ('String' | 'Boolean' | 'PositiveInteger' | 'Integer' | 'Double')
