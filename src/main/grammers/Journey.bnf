{
  parserClass="com.qalens.corr.lang.core.parser.JourneyParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jrn"
  psiImplClassSuffix="Impl"
  psiPackage="com.qalens.corr.lang.core.psi"
  psiImplPackage="com.qalens.corr.lang.core.psi.impl"

  elementTypeHolderClass="com.qalens.corr.lang.core.psi.JrnElementTypes"
  elementTypeClass="com.qalens.corr.lang.core.psi.JrnElementType"
  tokenTypeClass="com.qalens.corr.lang.core.psi.JrnTokenType"

  psiImplUtilClass="com.qalens.corr.lang.core.psi.impl.JourneyPsiImplUtil"
  tokens = [
          DOT = '.'
          SCRIPLET_START = '<%'
          SCRIPLET_END = '%>'
          LBRACE      = '{'
          RBRACE      = '}'
          LBRACK      =  '['
          RBRACK      =  ']'
          LPAREN      =  '('
          RPAREN      =  ')'
          COLON       =  ':'
          SEMICOLON   =  ';'
          COMMA       =  ','
          BACKTICK    =  '`'
          UNDERSCORE  =  '_'
          QUOTE      =  '"'
          ASSIGN     =  '='
          STRING      = 'String'
          BOOL      = 'Boolean'
          DOUBLE    = 'Double'
          POSITIVE_INTEGER = 'PositiveInteger'
          INTEGER = 'Integer'
          LIST      = 'List'
          OBJECT      = 'Object'
          CONCAT = 'concat'
          LPAD = 'lpad'
          RPAD = 'rpad'
          LEFT = 'left'
          RIGHT = 'right'
          MID = 'mid'
          FROMJSON = 'from_json'
          MUL = 'mul'
          DIV = 'div'
          ADD = 'add'
          SUB = 'sub'
          STATUS = 'status'
          FAKE = 'fake'
          CONTAINS = 'contains'
          ENCODE = 'encode'
          TIMESTAMP = 'timestamp'
          NOW = 'now'
          MOD = 'mod'
          UUID = 'uuid'
          ASYNC = 'async'
          WITH = 'with'
          RESPOND = 'respond'
          SYNC = 'sync'
          ON = 'on'
          LISTEN = 'listen'
          RANDOM = 'random'
          RANDOMELEMENT = 'random_element'
          ROUND = 'round'
          PRINT  = 'print'
          TEXT = 'text'
          FOR = 'for'
          PUSH = 'push'
          FORM = 'form'
          IF = 'if'
          TO = 'to'
          LOAD = 'load'
          FROM = 'from'
          SANDBOX = 'sandbox'
          ELSE = 'else'
          LET = 'let'
          MATCHING = 'matching'
          BODY = 'body'
          HEADERS = 'headers'
          REQUEST = 'request'
          AND = 'and'
          OBJECT_TEMPLATE = 'object'
          URL = 'url'
          GET = 'get'
          PUT = 'put'
          POST = 'post'
          PATCH = 'patch'
          DELETE = 'delete'
          FATARROW = '=>'
          OP_EQUAL = '=='
          OP_NOTEQUAL = '!='
          OP_PLUS = '+'
          OP_MINUS = '-'
          OP_DIVIDE = '/'
          OP_MULTIPLY = '*'
          OP_MOD = '%'
          OP_INCREMENT = '++'
          OP_DECREMENT = '--'
          LINE_COMMENT='regexp://..'
          BLOCK_COMMENT='regexp:/*..*/'

      ]
      extends(".*Step")=Step
}
journeyFile ::= RootFn
RootFn ::= JourneyName '(' ')' Block
JourneyName ::= identifier | NAME
Block ::= '{' Step* '}' {pin=1}
Step ::= PrintStep | AssignmentStep | SyncStep | ListenerStep | IfElseStep  | RestStep | VariableActionStep {recoverWhile="recoverStep"}
PrintStep ::= 'print' FillableTextTemplate { pin = 1 }
private recoverStep ::= ! (StepStart)
private StepStart ::= ('let' | 'sync' | 'listen' | 'if' | 'async' | 'print' | '}' | 'respond' | RestVerb | identifier )
AssignmentStep::= 'let' VariableReference '=' (Assignable | ('load' Expression ('from' 'sandbox' Expression)?)) {pin=1}
SyncStep ::= 'sync' VariableReference ('to' 'sandbox' Expression)? {pin=1}
ListenerStep ::= 'listen' 'on' Expression StubDefinitionBlock {pin=1}
StubDefinitionBlock ::= 'with' '{' StubDefinition* '}' { pin=1 }
IfElseStep ::= 'if' Expression Block ('else' 'if' Expression Block)* ('else' Block)? {pin=1}
RestStep ::= ('async')? RestVerb FillableRequestTemplate ( 'matching' (HeadersStartingRestData | BodyStartingRestData))? {pin=2}
VariableActionStep ::= VariableReference '.' (PushStepPart|ForStepPart) {pin = 3}
StubDefinition ::=  'on' RestVerb RequestMatcher RequestExtractor? ResponseGenerator {
    pin = 1
    recoverWhile="recoverStubDefinition"
 }
RequestMatcher ::= 'with' 'url' ExtractableText  {pin=1}
RequestExtractor::= 'matching' 'request' (HeadersStartingRestData | BodyStartingRestData) {pin = 1}
private recoverStubDefinition::= !('on'|'}' )
ResponseGenerator ::= '{' CalculationSteps ResponseLine '}' { pin = 1 }
CalculationSteps ::= Step* { recoverWhile="recoverCalculationSteps"}
private recoverCalculationSteps ::= !('respond' | '}' )
ResponseLine ::= 'respond' 'with' ('status' PositiveIntegerValue 'and')? 'body' Expression { pin =1 recoverWhile="recoverStep"}
RestVerb ::= 'get' | 'put' | 'post' | 'patch' | 'delete'
HeadersStartingRestData ::= HeadersDeclaration ('and' BodyDeclaration)? {pin=1}
BodyStartingRestData ::=   BodyDeclaration ('and' HeadersDeclaration)? { pin=1 }
HeadersDeclaration ::=  'headers' ExtractableHeaders {pin=1}
BodyDeclaration ::= 'body' ExtractableTemplate {pin=1}
ExtractableTemplate ::=   ExtractableObject | ExtractableForm
ExtractableForm ::= 'form' ExtractableFormTemplate {pin = 1}
ExtractableObject ::= 'object' ExtractableObjectTemplate {pin = 1}
ExtractableObjectTemplate ::= ExtractableObjectMap | ExtractableStaticArray | ExtractableForLoop | VariableReference
ExtractableObjectMap ::= '{' ExtractablePair ( ',' ExtractablePair)* '}' {pin=1}
ExtractableStaticArray ::= '[' ExtractableObjectTemplate (',' ExtractableObjectTemplate)* ']' {pin=1}
ExtractableForLoop ::= VariableReference '.' 'for' '(' VariableReference ')' '=>' ExtractableObjectTemplate {pin = 3}
ExtractablePair ::= STRING_LITERAL ':' ExtractableObjectTemplate {pin=1 recoverWhile="recoverExtractablePair"}
private recoverExtractablePair::=!(STRING_LITERAL|'}'|',')
ExtractableFormTemplate ::= '{'  ExtractableField (',' ExtractableField )* '}' {pin=1}
ExtractableField ::= STRING_LITERAL ':' VariableReference {pin = 1 recoverWhile="recoverExtractableField"}
private recoverExtractableField::= !(STRING_LITERAL | ',' | '}')
ExtractableHeaders ::= '{' STRING_LITERAL ':' VariableReference (',' STRING_LITERAL ':' VariableReference)* '}' {pin=1}
FillableRequestTemplate ::= 'request' '{'
        RequestTemplatePart
   '}' {pin = 2}
RequestTemplatePart::='url' ':' (Expression | FillableTextTemplate)
                        ( ',' 'body' ':' FillableObjectTemplate)?
                        ( ',' 'headers' ':' FillableHeaders)? {pin=1 recoverWhile=recoverRequestTemplatePart}
private recoverRequestTemplatePart ::= !('}')
FillableHeaders ::= '{' HeaderPair (',' HeaderPair)* '}' {pin=1}
HeaderPair ::= STRING_LITERAL ':' (Expression | FillableTextTemplate)
Assignable ::= Expression | FillableObjectTemplate | FillableTextTemplate
FillableObjectTemplate ::= 'object' ObjectValueTemplate {pin=1}
ObjectValueTemplate ::= FillableForLoop | Expression | FillableMapTemplate | FillableArrayTemplate
FillableMapTemplate ::= '{'  (FillbaleObjectPair (',' FillbaleObjectPair)*)? '}'
FillbaleObjectPair ::= STRING_LITERAL ':' ObjectValueTemplate
FillableArrayTemplate ::= '[' (ObjectValueTemplate (',' ObjectValueTemplate)*)? ']'
FillableForLoop ::= VariableReference '.' 'for' (FillableForLoopWithArguments | FillableForLoopWithoutArguments)
FillableForLoopWithArguments ::= '(' VariableReference (',' VariableReference )? ')' '=>' ObjectValueTemplate
FillableForLoopWithoutArguments ::= ObjectValueTemplate
ForStepPart ::= 'for' ( ArgedFor | UnArgedFor ) {pin=1}
PushStepPart ::=  'push' ( Expression ) {pin=1}
UnArgedFor ::= Step | Block
ArgedFor ::= '(' ( (VariableReference ',' VariableReference) | VariableReference?) ')' '=>' (Block | Step) {pin = 1}
FillableTextTemplate ::= 'text' TextTemplate
ExtractableText ::= 'text' '`' (SingleVariableText | MultiVariableText) '`'
SingleVariableText ::= '<%' VariableExpression '%>'
MultiVariableText ::= (TEXT_LITERAL)? ('<%' VariableExpression '%>' TEXT_LITERAL)* ('<%' VariableExpression '%>')?
TextTemplate ::= '`' TextBlock* '`'
TextBlock ::= Scriplet | TEXT_LITERAL
Scriplet ::= '<%' (TextScript) '%>'
TextScript ::= ForLoopInText | Expression
ForLoopInText ::= VariableReference '.' 'for' (UnArgedForInText | ArgedForInText )
UnArgedForInText ::= ForBlockForText
ForBlockForText ::= TextScript | ( '%>' (TextBlock)* '<%' )
ArgedForInText ::= '(' ( (VariableReference ',' VariableReference) | VariableReference?) ')' '=>' ForBlockForText
Expression ::=  OperatorExpression | NonOperatorExpression
NonOperatorExpression  ::= BracketedExpression | ConstantExpression | FunctionExpression | VariableExpression
BracketedExpression ::= '(' Expression ')'
OperatorExpression ::= BinaryOperatorExpression | UnaryOperatorExpression
BinaryOperatorExpression ::= ((UnaryOperatorExpression | NonOperatorExpression) BinaryOperator)+ (UnaryOperatorExpression | NonOperatorExpression)
UnaryOperatorExpression ::= NonOperatorExpression UnaryOperator
BinaryOperator ::= '+' | '-' | '/' | '*' | '%' | '==' | '!='
UnaryOperator ::= '++' | '--'
ConstantExpression ::= STRING_LITERAL | DoubleValue | PositiveIntegerValue | InetegerValue | NullValue | BooleanValue
FunctionExpression ::= MultiValuedFunction | BinaryFunction | UnaryFunction | NoArgFunction
MultiValuedFunction ::=  (VariableReference '.')? ('concat' | 'mul' | 'add' | 'lpad' | 'rpad' | 'mid') '(' (Expression (',' Expression)*)? ')'
BinaryFunction ::= (VariableReference '.' ('round' | 'random' | 'sub' | 'div' | 'mod' | 'left' | 'right') '(' Expression ')') | (('round' | 'random' | 'sub' | 'div' | 'mod' | 'left' | 'right') '(' (Expression ',' Expression)  ')')
UnaryFunction ::= (VariableReference '.' ('fake' | 'from_json' | 'random_element' | 'encode' | 'now'  ) '('')')|(('fake' | 'from_json' | 'random_element' | 'encode' | 'now'  ) '(' Expression  ')')
NoArgFunction ::= ('uuid' |  'timestamp' | 'now' ) '('  ')'
VariableExpression ::= VariableReference (':' Type)?
VariableReference ::= identifier ('.' identifier)* {pin=1}
Type ::= ('String' | 'Boolean' | 'PositiveInteger' | 'Integer' | 'Double')
