{
  parserClass="com.qalens.corr.lang.core.parser.JourneyParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jrn"
  psiImplClassSuffix="Impl"
  psiPackage="com.qalens.corr.lang.core.psi"
  psiImplPackage="com.qalens.corr.lang.core.psi.impl"

  elementTypeHolderClass="com.qalens.corr.lang.core.psi.JrnElementTypes"
  elementTypeClass="com.qalens.corr.lang.core.psi.JrnElementType"
  tokenTypeClass="com.qalens.corr.lang.core.psi.JrnTokenType"

  psiImplUtilClass="com.qalens.corr.lang.core.psi.impl.JourneyPsiImplUtil"
  tokens = [
          DOT = '.'
          SCRIPLET_START = '<%'
          SCRIPLET_END = '%>'
          LBRACE      = '{'
          RBRACE      = '}'
          LBRACK      =  '['
          RBRACK      =  ']'
          LPAREN      =  '('
          RPAREN      =  ')'
          COLON       =  ':'
          SEMICOLON   =  ';'
          COMMA       =  ','
          BACKTICK    =  '`'
          UNDERSCORE  =  '_'
          QUOTE      =  '"'
          OP_ASIGNMENT  =  '='
          STRING      = 'String'
          BOOL      = 'Boolean'
          DOUBLE    = 'Double'
          POSITIVE_INTEGER = 'PositiveInteger'
          INTEGER = 'Integer'
          LIST      = 'List'
          OBJECT      = 'Object'
          CONCAT = 'concat'
          MUL = 'mul'
          DIV = 'div'
          ADD = 'add'
          SUB = 'sub'
          UUID = 'uuid'
          RANDOM = 'random'
          ROUND = 'round'
          PRINT  = 'print'
          FILLABLE = 'fillable'
          TEXT = 'text'

      ]
}
journeyFile ::= RootFn
RootFn ::= JourneyName LPAREN RPAREN LBRACE Statement* RBRACE
JourneyName ::= identifier | NAME
Statement ::= PrintStatement
PrintStatement ::= PRINT DynamicFillableTextTemplate SEMICOLON
DynamicFillableTextTemplate ::= FILLABLE TEXT TextTemplate
TextTemplate ::= BACKTICK TextBlock* BACKTICK
TextBlock ::= Scriplet | TEXT_LITERAL
Scriplet ::= SCRIPLET_START (TextScript) SCRIPLET_END
TextScript ::= Expression
Expression ::= ConstantExpression | FunctionExpression | VariableExpression
ConstantExpression ::= STRING_LITERAL | DoubleValue | PositiveIntegerValue | InetegerValue | NullValue | BooleanValue
FunctionExpression ::= MultiValuedFunction | BinaryFunction | NoArgFunction
MultiValuedFunction ::= (CONCAT | MUL | ADD) LPAREN (Expression (',' Expression)*)? RPAREN
BinaryFunction ::= (ROUND | RANDOM | SUB | DIV) LPAREN (Expression COMMA Expression)  RPAREN
NoArgFunction ::= UUID LPAREN  RPAREN
VariableExpression ::= VariableReference (':' Type)?
VariableReference ::= identifier (DOT identifier)*
Type ::= (STRING | BOOL | POSITIVE_INTEGER | INTEGER | DOUBLE)
//journeyFile ::= RootFn
//RootFn ::= Label '{' Statement* '}'
//Label ::= identifier | NAME
//Statement ::= (DefinedFnCall | ForStatement | LetStatement) ';';
//LetStatement ::=  LET identifier OP_ASIGNMENT Expression
//ForStatement ::= FOR '(' (identifier (':' Type) IN identifier (':' Type)?) ')' '{' Statement * '}'
//DefinedFnCall ::= DefinedMethod '(' (Argument ',')* Argument? ')'
//DefinedMethod::= RestMethod | SystemMethod
//Argument ::= identifier ':' Value
//Value ::= TextTemplateValue | JsonTemplateValue | EJsonTemplateValue | Nil | ReqHeadersValue | ResHeadersValue
//Nil ::= NILVALUE
//TextTemplateValue ::= TextStart QUOTE TextTemplate QUOTE
//VarTemplateValue ::=  SCRIPLET_START VariableExpression SCRIPLET_END
//JsonTemplateValue ::= JsonStart JsonTemplate
//MapValue ::= MapStart MapObject
//ReqHeadersValue ::=  ReqHeadersValueStart LBRACE (ReqHeaderPair ( COMMA ReqHeaderPair)*) RBRACE
//ReqHeaderPair ::= STRING_LITERAL COLON TextTemplateValue
//ResHeadersValue ::=  ResHeadersValueStart LBRACE (ResHeaderPair ( COMMA ResHeaderPair)*) RBRACE
//ResHeaderPair ::= STRING_LITERAL COLON VarTemplateValue
//EJsonTemplateValue ::= EjsonStart EJsonTemplate
//TextTemplate ::= TextBlock*
//TextBlock ::= ForBlock| Scriplet | TEXT_LITERAL
//EJsonTemplate ::= EScriplet | EJsonArray | EJsonObject
//JsonTemplate ::= Scriplet | JsonArray | JsonObject | STRING_LITERAL
//Scriplet ::= SCRIPLET_START (Expression) SCRIPLET_END
//FOR_LOOP ::= FOR '('(identifier (':' Type) IN identifier (':' Type)?) ')' LBRACE (FOR_LOOP | FOR_VALUE_SCRIPTLET) RBRACE
//FOR_VALUE_SCRIPTLET ::= FOR_SCRIPLET_END JsonTemplate FOR_SCRIPLET_START
//EFOR_LOOP ::= FOR '('(identifier (':' Type) IN identifier (':' Type)?) ')' LBRACE (EFOR_LOOP | EFOR_VALUE_SCRIPTLET) RBRACE
//EFOR_VALUE_SCRIPTLET ::= FOR_SCRIPLET_END EJsonTemplate FOR_SCRIPLET_START
//TFOR_LOOP ::= FOR '('(identifier (':' Type) IN identifier (':' Type)?) ')' LBRACE (TFOR_LOOP | TFOR_VALUE_SCRIPTLET) RBRACE
//TFOR_VALUE_SCRIPTLET ::= FOR_SCRIPLET_END TextTemplate FOR_SCRIPLET_START
//JsonArray ::= '[' ((FOR_SCRIPLET_START FOR_LOOP FOR_SCRIPLET_END) | ((JsonTemplate ',')* JsonTemplate))?']'
//EJsonArray ::= '[' ((FOR_SCRIPLET_START EFOR_LOOP FOR_SCRIPLET_END) | ((EJsonTemplate ',')* EJsonTemplate))?']'
//JsonObject ::= '{' (JsonPair ',')* JsonPair? '}'
//MapObject ::= '{' (MapPair ',')* MapPair? '}'
//EJsonObject ::= '{' (EJsonPair ',')* EJsonPair? '}'
//JsonPair ::= STRING_LITERAL ':' (Scriplet | JsonArray | JsonObject | STRING_LITERAL | DoubleValue | LongValue | BooleanValue)
//MapPair ::= STRING_LITERAL ':' (TextTemplateValue | STRING_LITERAL )
//EJsonPair ::= STRING_LITERAL ':' (EScriplet | EJsonArray | EJsonObject)
//Expression ::= ConstantExpression | FunctionExpression | VariableExpression
//FunctionExpression ::= MultiValuedFunction | BinaryFunction | NoArgFunction
//MultiValuedFunction ::= (CONCAT | MUL | ADD) '(' (Expression (',' Expression)*)? ')'
//BinaryFunction ::= (ROUND | RANDOM) '(' (Expression (',' Expression)*)?  ')'
//NoArgFunction ::= UUID '('  ')'
//VariableExpression ::= identifier (':' Type)?
//ConstantExpression ::= STRING_LITERAL | DoubleValue | LongValue | BooleanValue
//
////Expression ::= identifier ((':' Type) | ('(' ( STRING_LITERAL | LongValue | BooleanValue| Expression) ( ',' (STRING_LITERAL | LongValue | BooleanValue | Expression))* ')'))?
//EScriplet ::= SCRIPLET_START identifier (':' Type)? SCRIPLET_END
//Type ::= (STRING | LONG | LIST | OBJECT)
//ForBlock ::= (FOR_SCRIPLET_START TFOR_LOOP FOR_SCRIPLET_END)
