{
  parserClass="com.qalens.corr.lang.core.parser.JourneyParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jrn"
  psiImplClassSuffix="Impl"
  psiPackage="com.qalens.corr.lang.core.psi"
  psiImplPackage="com.qalens.corr.lang.core.psi.impl"

  elementTypeHolderClass="com.qalens.corr.lang.core.psi.JrnElementTypes"
  elementTypeClass="com.qalens.corr.lang.core.psi.JrnElementType"
  tokenTypeClass="com.qalens.corr.lang.core.psi.JrnTokenType"

  psiImplUtilClass="com.qalens.corr.lang.core.psi.impl.JourneyPsiImplUtil"
  tokens = [
          DOT = '.'
          SCRIPLET_START = '<%'
          SCRIPLET_END = '%>'
          LBRACE      = '{'
          RBRACE      = '}'
          LBRACK      =  '['
          RBRACK      =  ']'
          LPAREN      =  '('
          RPAREN      =  ')'
          COLON       =  ':'
          SEMICOLON   =  ';'
          COMMA       =  ','
          BACKTICK    =  '`'
          UNDERSCORE  =  '_'
          QUOTE      =  '"'
          ASSIGN     =  '='
          STRING      = 'String'
          BOOL      = 'Boolean'
          DOUBLE    = 'Double'
          POSITIVE_INTEGER = 'PositiveInteger'
          INTEGER = 'Integer'
          LIST      = 'List'
          OBJECT      = 'Object'
          CONCAT = 'concat'
          MUL = 'mul'
          DIV = 'div'
          ADD = 'add'
          SUB = 'sub'
          UUID = 'uuid'
          RANDOM = 'random'
          ROUND = 'round'
          PRINT  = 'print'
          FILLABLE = 'fillable'
          TEXT = 'text'
          FOR = 'for'
          LET = 'let'
          OBJECT_TEMPLATE = 'object'
          FATARROW = '=>'

      ]
}
journeyFile ::= RootFn
RootFn ::= JourneyName '(' ')' '{' Statement* '}'
JourneyName ::= identifier | NAME
Statement ::= PrintStatement | ForStatement | LetStatement
LetStatement ::= 'let' VariableReference '=' Assignable
Assignable ::= Expression | FillableObjectTemplate | FillableTextTemplate
FillableObjectTemplate ::= 'fillable' 'object' ObjectValueTemplate
ObjectValueTemplate ::= Expression | FillableMapTemplate | FillableArrayTemplate
FillableMapTemplate ::= '('  (FillbaleObjectPair (',' FillbaleObjectPair)*)? '}'
FillbaleObjectPair ::= STRING_LITERAL ':' ObjectValueTemplate
FillableArrayTemplate ::= '[' (ObjectValueTemplate (',' ObjectValueTemplate)*)? ']'
PrintStatement ::= 'print' FillableTextTemplate
ForStatement ::= VariableReference '.' 'for' ( UnArgedFor | ArgedFor)
UnArgedFor ::= Statement | MultipleStatement
ArgedFor ::= '(' ( (VariableReference ',' VariableReference) | VariableReference?) ')' '=>' (Statement | MultipleStatement)
MultipleStatement ::= '{' (Statement)* '}'
FillableTextTemplate ::= 'fillable' 'text' TextTemplate
TextTemplate ::= '`' TextBlock* '`'
TextBlock ::= Scriplet | TEXT_LITERAL
Scriplet ::= '<%' (TextScript) '%>'
TextScript ::= ForLoopInText | Expression
ForLoopInText ::= VariableReference '.' 'for' (UnArgedForInText | ArgedForInText )
UnArgedForInText ::= ForBlockForText
ForBlockForText ::= TextScript | ( '%>' (TextBlock)* '<%' )
ArgedForInText ::= '(' ( (VariableReference ',' VariableReference) | VariableReference?) ')' '=>' ForBlockForText
Expression ::= ConstantExpression | FunctionExpression | VariableExpression
ConstantExpression ::= STRING_LITERAL | DoubleValue | PositiveIntegerValue | InetegerValue | NullValue | BooleanValue
FunctionExpression ::= MultiValuedFunction | BinaryFunction | NoArgFunction
MultiValuedFunction ::= ('concat' | 'mul' | 'add') '(' (Expression (',' Expression)*)? ')'
BinaryFunction ::= ('round' | 'random' | 'sub' | 'div') '(' (Expression ',' Expression)  ')'
NoArgFunction ::= UUID '('  ')'
VariableExpression ::= VariableReference (':' Type)?
VariableReference ::= identifier ('.' identifier)*
Type ::= ('String' | 'Boolean' | 'PositiveInteger' | 'integer' | 'double')
//journeyFile ::= RootFn
//RootFn ::= Label '{' Statement* '}'
//Label ::= identifier | NAME
//Statement ::= (DefinedFnCall | ForStatement | LetStatement) ';';
//LetStatement ::=  LET identifier OP_ASIGNMENT Expression
//ForStatement ::= FOR '(' (identifier (':' Type) IN identifier (':' Type)?) ')' '{' Statement * '}'
//DefinedFnCall ::= DefinedMethod '(' (Argument ',')* Argument? ')'
//DefinedMethod::= RestMethod | SystemMethod
//Argument ::= identifier ':' Value
//Value ::= TextTemplateValue | JsonTemplateValue | EJsonTemplateValue | Nil | ReqHeadersValue | ResHeadersValue
//Nil ::= NILVALUE
//TextTemplateValue ::= TextStart QUOTE TextTemplate QUOTE
//VarTemplateValue ::=  SCRIPLET_START VariableExpression SCRIPLET_END
//JsonTemplateValue ::= JsonStart JsonTemplate
//MapValue ::= MapStart MapObject
//ReqHeadersValue ::=  ReqHeadersValueStart LBRACE (ReqHeaderPair ( COMMA ReqHeaderPair)*) '}'
//ReqHeaderPair ::= STRING_LITERAL COLON TextTemplateValue
//ResHeadersValue ::=  ResHeadersValueStart LBRACE (ResHeaderPair ( COMMA ResHeaderPair)*) '}'
//ResHeaderPair ::= STRING_LITERAL COLON VarTemplateValue
//EJsonTemplateValue ::= EjsonStart EJsonTemplate
//TextTemplate ::= TextBlock*
//TextBlock ::= ForBlock| Scriplet | TEXT_LITERAL
//EJsonTemplate ::= EScriplet | EJsonArray | EJsonObject
//JsonTemplate ::= Scriplet | JsonArray | JsonObject | STRING_LITERAL
//Scriplet ::= SCRIPLET_START (Expression) SCRIPLET_END
//FOR_LOOP ::= FOR '('(identifier (':' Type) IN identifier (':' Type)?) ')' LBRACE (FOR_LOOP | FOR_VALUE_SCRIPTLET) '}'
//FOR_VALUE_SCRIPTLET ::= FOR_SCRIPLET_END JsonTemplate FOR_SCRIPLET_START
//EFOR_LOOP ::= FOR '('(identifier (':' Type) IN identifier (':' Type)?) ')' LBRACE (EFOR_LOOP | EFOR_VALUE_SCRIPTLET) '}'
//EFOR_VALUE_SCRIPTLET ::= FOR_SCRIPLET_END EJsonTemplate FOR_SCRIPLET_START
//TFOR_LOOP ::= FOR '('(identifier (':' Type) IN identifier (':' Type)?) ')' LBRACE (TFOR_LOOP | TFOR_VALUE_SCRIPTLET) '}'
//TFOR_VALUE_SCRIPTLET ::= FOR_SCRIPLET_END TextTemplate FOR_SCRIPLET_START
//JsonArray ::= '[' ((FOR_SCRIPLET_START FOR_LOOP FOR_SCRIPLET_END) | ((JsonTemplate ',')* JsonTemplate))?']'
//EJsonArray ::= '[' ((FOR_SCRIPLET_START EFOR_LOOP FOR_SCRIPLET_END) | ((EJsonTemplate ',')* EJsonTemplate))?']'
//JsonObject ::= '{' (JsonPair ',')* JsonPair? '}'
//MapObject ::= '{' (MapPair ',')* MapPair? '}'
//EJsonObject ::= '{' (EJsonPair ',')* EJsonPair? '}'
//JsonPair ::= STRING_LITERAL ':' (Scriplet | JsonArray | JsonObject | STRING_LITERAL | DoubleValue | LongValue | BooleanValue)
//MapPair ::= STRING_LITERAL ':' (TextTemplateValue | STRING_LITERAL )
//EJsonPair ::= STRING_LITERAL ':' (EScriplet | EJsonArray | EJsonObject)
//Expression ::= ConstantExpression | FunctionExpression | VariableExpression
//FunctionExpression ::= MultiValuedFunction | BinaryFunction | NoArgFunction
//MultiValuedFunction ::= (CONCAT | MUL | ADD) '(' (Expression (',' Expression)*)? ')'
//BinaryFunction ::= (ROUND | RANDOM) '(' (Expression (',' Expression)*)?  ')'
//NoArgFunction ::= UUID '('  ')'
//VariableExpression ::= identifier (':' Type)?
//ConstantExpression ::= STRING_LITERAL | DoubleValue | LongValue | BooleanValue
//
////Expression ::= identifier ((':' Type) | ('(' ( STRING_LITERAL | LongValue | BooleanValue| Expression) ( ',' (STRING_LITERAL | LongValue | BooleanValue | Expression))* ')'))?
//EScriplet ::= SCRIPLET_START identifier (':' Type)? SCRIPLET_END
//Type ::= (STRING | LONG | LIST | OBJECT)
//ForBlock ::= (FOR_SCRIPLET_START TFOR_LOOP FOR_SCRIPLET_END)
